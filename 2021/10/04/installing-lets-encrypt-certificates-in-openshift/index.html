<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Installing Let’s Encrypt certificates in OpenShift | Viktor's blog</title>
<meta name=keywords content="OpenShift">
<meta name=description content="Introduction At my homelab I deploy and destroy OpenShift clusters several times a day. One of the most annoying things for me is accessing OpenShift console when it doesn&rsquo;t have proper certificates installed: browser warns about self-signed certificates and makes me do several clicks first in order to access the UI. And of course, in real-life deployments you have to use proper certificates to secure routes and API endpoints.
These days it&rsquo;s easy to obtain free TLS certificates using Let&rsquo;s Encrypt or similar services.">
<meta name=author content="Viktor Ashirov">
<link rel=canonical href=https://vashirov.blog/2021/10/04/installing-lets-encrypt-certificates-in-openshift/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style>
<link rel=icon href=https://vashirov.blog/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://vashirov.blog/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://vashirov.blog/favicon-32x32.png>
<link rel=apple-touch-icon href=https://vashirov.blog/apple-touch-icon.png>
<link rel=mask-icon href=https://vashirov.blog/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Installing Let’s Encrypt certificates in OpenShift">
<meta property="og:description" content="Introduction At my homelab I deploy and destroy OpenShift clusters several times a day. One of the most annoying things for me is accessing OpenShift console when it doesn&rsquo;t have proper certificates installed: browser warns about self-signed certificates and makes me do several clicks first in order to access the UI. And of course, in real-life deployments you have to use proper certificates to secure routes and API endpoints.
These days it&rsquo;s easy to obtain free TLS certificates using Let&rsquo;s Encrypt or similar services.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://vashirov.blog/2021/10/04/installing-lets-encrypt-certificates-in-openshift/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-10-04T16:11:53+02:00">
<meta property="article:modified_time" content="2021-10-04T16:11:53+02:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Installing Let’s Encrypt certificates in OpenShift">
<meta name=twitter:description content="Introduction At my homelab I deploy and destroy OpenShift clusters several times a day. One of the most annoying things for me is accessing OpenShift console when it doesn&rsquo;t have proper certificates installed: browser warns about self-signed certificates and makes me do several clicks first in order to access the UI. And of course, in real-life deployments you have to use proper certificates to secure routes and API endpoints.
These days it&rsquo;s easy to obtain free TLS certificates using Let&rsquo;s Encrypt or similar services.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vashirov.blog/posts/"},{"@type":"ListItem","position":2,"name":"Installing Let’s Encrypt certificates in OpenShift","item":"https://vashirov.blog/2021/10/04/installing-lets-encrypt-certificates-in-openshift/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Installing Let’s Encrypt certificates in OpenShift","name":"Installing Let’s Encrypt certificates in OpenShift","description":"Introduction At my homelab I deploy and destroy OpenShift clusters several times a day. One of the most annoying things for me is accessing OpenShift console when it doesn\u0026rsquo;t have proper certificates installed: browser warns about self-signed certificates and makes me do several clicks first in order to access the UI. And of course, in real-life deployments you have to use proper certificates to secure routes and API endpoints.\nThese days it\u0026rsquo;s easy to obtain free TLS certificates using Let\u0026rsquo;s Encrypt or similar services.","keywords":["OpenShift"],"articleBody":"Introduction At my homelab I deploy and destroy OpenShift clusters several times a day. One of the most annoying things for me is accessing OpenShift console when it doesn’t have proper certificates installed: browser warns about self-signed certificates and makes me do several clicks first in order to access the UI. And of course, in real-life deployments you have to use proper certificates to secure routes and API endpoints.\nThese days it’s easy to obtain free TLS certificates using Let’s Encrypt or similar services. In March 2018 Let’s Encrypt added support for wildcard certificates, that made it finally possible to use it for my OpenShift deployments. I use acme.sh together with DNS API for DNS chanllenge.\nSolution Usually I have 2 different versions of clusters running at the same time: stable and development. So I need to request a wildcard certificate for my main domain plus for api and *.apps subdomains for both clusters:\n$ export DOMAIN=my_domain.fqdn $ acme.sh --issue --dns dns_dreamhost \\  -d '$DOMAIN' \\  -d '*.$DOMAIN' \\  -d 'api.stable.$DOMAIN' \\  -d 'api.devel.$DOMAIN' \\  -d '*.apps.stable.$DOMAIN' \\  -d '*.apps.devel.$DOMAIN' Installing the certificate Once you sucessfully receive the certificate, it’s time to install it. There are 2 places where we need to introduce new certificates: ingress controller and API server.\nIngress controller Create a secret that contains full certificate chain and private key in the openshift-ingress namespace:\n$ oc create secret tls letsencrypt-certs -n openshift-ingress \\  --cert=${HOME}/.acme.sh/${DOMAIN}/fullchain.cer \\  --key=${HOME}/.acme.sh/${DOMAIN}/${DOMAIN}.key \\  --dry-run=client -o yaml | oc apply -f - Then update the ingress controller to use the created secret:\n$ oc patch ingresscontroller default -n openshift-ingress-operator \\  --type=merge --patch='{\"spec\": { \"defaultCertificate\": { \"name\": \"letsencrypt-certs\" }}}' API server Same for the API server: Create a secret that contains full certificate chain and private key in the openshift-config namespace:\n$ oc create secret tls letsencrypt-certs -n openshift-config \\  --cert=${HOME}/.acme.sh/${DOMAIN}/fullchain.cer \\  --key=${HOME}/.acme.sh/${DOMAIN}/${DOMAIN}.key \\  --dry-run=client -o yaml | oc apply -f - And update the API server with the new secret reference:\n$ export CLUSTER=stable $ oc patch apiserver cluster --type=merge \\  -p '{\"spec\":{\"servingCerts\": {\"namedCertificates\": [{\"names\": [\"api.'${CLUSTER}'.'${DOMAIN}\"], \"servingCertificate\": {\"name\": \"letsencrypt-certs\"}}]}}}' It will take some time to rebuild the containers and deploy the pods, but once it’s done you would be able to connect to the cluster console without any warnings.\nFixing oc client You might encounter one issue with the CLI tools if they use an old KUBECONFIG. If it references old CA data, you won’t be able to connect to the cluster:\n$ oc whoami Unable to connect to the server: x509: certificate signed by unknown authority The solution is to remove the old CA data from your KUBECONFIG:\n$ sed -i -e \"s/\\(certificate-authority-data:\\).*//\" $KUBECONFIG And after that connection succeeds:\n$ oc whoami system:admin References:  https://docs.openshift.com/container-platform/4.8/security/certificates/replacing-default-ingress-certificate.html https://docs.openshift.com/container-platform/4.8/security/certificates/api-server.html  ","wordCount":"453","inLanguage":"en","datePublished":"2021-10-04T16:11:53+02:00","dateModified":"2021-10-04T16:11:53+02:00","author":{"@type":"Person","name":"Viktor Ashirov"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vashirov.blog/2021/10/04/installing-lets-encrypt-certificates-in-openshift/"},"publisher":{"@type":"Organization","name":"Viktor's blog","logo":{"@type":"ImageObject","url":"https://vashirov.blog/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://vashirov.blog/ accesskey=h title="Viktor's blog (Alt + H)">Viktor's blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://vashirov.blog/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://vashirov.blog/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://vashirov.blog/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://vashirov.blog/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://vashirov.blog/index.xml title=RSS>
<span>RSS</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Installing Let’s Encrypt certificates in OpenShift
</h1>
<div class=post-meta>October 4, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Viktor Ashirov
</div>
</header>
<div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1>
<p>At my homelab I deploy and destroy OpenShift clusters several times a day. One of the most annoying things for me is accessing OpenShift console when it doesn&rsquo;t have proper certificates installed: browser warns about self-signed certificates and makes me do several clicks first in order to access the UI. And of course, in real-life deployments you have to use proper certificates to secure routes and API endpoints.</p>
<p>These days it&rsquo;s easy to obtain free TLS certificates using Let&rsquo;s Encrypt or similar services. In March 2018 Let&rsquo;s Encrypt <a href=https://community.letsencrypt.org/t/acme-v2-and-wildcard-certificate-support-is-live/55579>added</a> support for wildcard certificates, that made it finally possible to use it for my OpenShift deployments. I use <code>acme.sh</code> together with <a href=https://github.com/acmesh-official/acme.sh/wiki/dnsapi>DNS API</a> for <a href=https://letsencrypt.org/docs/challenge-types/>DNS chanllenge</a>.</p>
<h1 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h1>
<p>Usually I have 2 different versions of clusters running at the same time: stable and development. So I need to request a wildcard certificate for my main domain plus for api and *.apps subdomains for both clusters:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ export DOMAIN<span style=color:#f92672>=</span>my_domain.fqdn
$ acme.sh --issue --dns dns_dreamhost <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -d <span style=color:#e6db74>&#39;$DOMAIN&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -d <span style=color:#e6db74>&#39;*.$DOMAIN&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -d <span style=color:#e6db74>&#39;api.stable.$DOMAIN&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -d <span style=color:#e6db74>&#39;api.devel.$DOMAIN&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -d <span style=color:#e6db74>&#39;*.apps.stable.$DOMAIN&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -d <span style=color:#e6db74>&#39;*.apps.devel.$DOMAIN&#39;</span>
</code></pre></div><h2 id=installing-the-certificate>Installing the certificate<a hidden class=anchor aria-hidden=true href=#installing-the-certificate>#</a></h2>
<p>Once you sucessfully receive the certificate, it&rsquo;s time to install it. There are 2 places where we need to introduce new certificates: ingress controller and API server.</p>
<h3 id=ingress-controller>Ingress controller<a hidden class=anchor aria-hidden=true href=#ingress-controller>#</a></h3>
<p>Create a secret that contains full certificate chain and private key in the <code>openshift-ingress</code> namespace:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ oc create secret tls letsencrypt-certs -n openshift-ingress <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --cert<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>HOME<span style=color:#e6db74>}</span>/.acme.sh/<span style=color:#e6db74>${</span>DOMAIN<span style=color:#e6db74>}</span>/fullchain.cer <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --key<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>HOME<span style=color:#e6db74>}</span>/.acme.sh/<span style=color:#e6db74>${</span>DOMAIN<span style=color:#e6db74>}</span>/<span style=color:#e6db74>${</span>DOMAIN<span style=color:#e6db74>}</span>.key <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --dry-run<span style=color:#f92672>=</span>client -o yaml | oc apply -f - 

</code></pre></div><p>Then update the ingress controller to use the created secret:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ oc patch ingresscontroller default -n openshift-ingress-operator <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --type<span style=color:#f92672>=</span>merge --patch<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;{&#34;spec&#34;: { &#34;defaultCertificate&#34;: { &#34;name&#34;: &#34;letsencrypt-certs&#34; }}}&#39;</span>
</code></pre></div><h3 id=api-server>API server<a hidden class=anchor aria-hidden=true href=#api-server>#</a></h3>
<p>Same for the API server:
Create a secret that contains full certificate chain and private key in the <code>openshift-config</code> namespace:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ oc create secret tls letsencrypt-certs -n openshift-config <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --cert<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>HOME<span style=color:#e6db74>}</span>/.acme.sh/<span style=color:#e6db74>${</span>DOMAIN<span style=color:#e6db74>}</span>/fullchain.cer <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --key<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>HOME<span style=color:#e6db74>}</span>/.acme.sh/<span style=color:#e6db74>${</span>DOMAIN<span style=color:#e6db74>}</span>/<span style=color:#e6db74>${</span>DOMAIN<span style=color:#e6db74>}</span>.key <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --dry-run<span style=color:#f92672>=</span>client -o yaml | oc apply -f - 
</code></pre></div><p>And update the API server with the new secret reference:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ export CLUSTER<span style=color:#f92672>=</span>stable
$ oc patch apiserver cluster --type<span style=color:#f92672>=</span>merge <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -p <span style=color:#e6db74>&#39;{&#34;spec&#34;:{&#34;servingCerts&#34;: {&#34;namedCertificates&#34;:  [{&#34;names&#34;: [&#34;api.&#39;</span><span style=color:#e6db74>${</span>CLUSTER<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;.&#39;</span><span style=color:#e6db74>${</span>DOMAIN<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;],  &#34;</span>servingCertificate<span style=color:#e6db74>&#34;: {&#34;</span>name<span style=color:#e6db74>&#34;: &#34;</span>letsencrypt-certs<span style=color:#e6db74>&#34;}}]}}}&#39; 
</span></code></pre></div><p>It will take some time to rebuild the containers and deploy the pods, but once it&rsquo;s done you would be able to connect to the cluster console without any warnings.</p>
<h2 id=fixing-oc-client>Fixing <code>oc</code> client<a hidden class=anchor aria-hidden=true href=#fixing-oc-client>#</a></h2>
<p>You might encounter one issue with the CLI tools if they use an old KUBECONFIG. If it references old CA data, you won&rsquo;t be able to connect to the cluster:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ oc whoami
Unable to connect to the server: x509: certificate signed by unknown authority

</code></pre></div><p>The solution is to remove the old CA data from your KUBECONFIG:</p>
<pre tabindex=0><code>$ sed -i -e &quot;s/\(certificate-authority-data:\).*//&quot; $KUBECONFIG
</code></pre><p>And after that connection succeeds:</p>
<pre tabindex=0><code>$ oc whoami
system:admin
</code></pre><h3 id=references>References:<a hidden class=anchor aria-hidden=true href=#references>#</a></h3>
<ul>
<li><a href=https://docs.openshift.com/container-platform/4.8/security/certificates/replacing-default-ingress-certificate.html>https://docs.openshift.com/container-platform/4.8/security/certificates/replacing-default-ingress-certificate.html</a></li>
<li><a href=https://docs.openshift.com/container-platform/4.8/security/certificates/api-server.html>https://docs.openshift.com/container-platform/4.8/security/certificates/api-server.html</a></li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://vashirov.blog/tags/openshift/>OpenShift</a></li>
</ul>
</footer><script>document.write('<script src="https://utteranc.es/client.js" repo="vashirov/vashirov.github.io" issue-term="pathname" label="comment" '),document.body.className.includes("dark")?document.write('theme="github-dark"'):document.write('theme="github-light"'),document.write(' crossorigin="anonymous" async><\/script>')</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){const a=document.querySelector('iframe').contentWindow;a.postMessage({type:'set-theme',theme:'github-light'},'https://utteranc.es')}else{const a=document.querySelector('iframe').contentWindow;a.postMessage({type:'set-theme',theme:'github-dark'},'https://utteranc.es')}})</script>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://vashirov.blog/>Viktor's blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>